// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  username  String   @unique @db.VarChar(50)
  email     String   @unique @db.VarChar(255)
  password  String
  rating    Int      @default(1200)

  // Anti-cheat fields
  isCheater      Boolean   @default(false)
  cheaterUntil   DateTime? // null = permanent, date = temporary ban
  cheatingStrikes Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  submissions     Submission[]
  solutions       Solution[]
  discussions     Discussion[]
  progress        UserProgress[]
  solutionVotes   SolutionVote[]
  ratingHistory   RatingHistory[]
  submissionFlags SubmissionFlag[]
  receivedFlags   SubmissionFlag[] @relation("FlaggedUser")
  rateLimitLogs   RateLimitLog[]

  @@map("users")
}

model Problem {
  id               String   @id @default(cuid())
  number           String   @unique @db.VarChar(20) // LH-001 format
  title            String   @db.VarChar(255)
  source           String   @db.VarChar(100) // IOL, APLO, etc.
  year             Int
  difficulty       Int      @default(1) // 1-5 stars
  rating           Int      @default(1200) // 1000-2400 complexity
  content          String   @db.Text // Problem statement
  pdfUrl           String?  @db.VarChar(500) // URL to problem PDF
  solutionUrl      String?  @db.VarChar(500) // URL to solution PDF
  officialSolution String?  @db.Text
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  tags          ProblemTag[]
  submissions   Submission[]
  solutions     Solution[]
  discussions   Discussion[]
  progress      UserProgress[]
  ratingHistory RatingHistory[]

  @@map("problems")
}

model Tag {
  id       String @id @default(cuid())
  name     String @unique @db.VarChar(100)
  category String @db.VarChar(50) // subfield, difficulty, etc.

  // Relations
  problems ProblemTag[]

  @@map("tags")
}

model ProblemTag {
  problemId String
  tagId     String

  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([problemId, tagId])
  @@map("problem_tags")
}

// Submission - Private attempts to solve problems
model Submission {
  id        String   @id @default(cuid())
  problemId String
  userId    String
  content   String   @db.Text
  status    String   @default("pending") // pending, judging, accepted, wrong_answer, partial

  // File attachments (images/PDFs)
  attachments Json? // Array of {url: string, type: 'image' | 'pdf', filename: string, size: number}

  // LLM evaluation results
  llmScore       Int?     // 0-100 score from LLM
  llmFeedback    String?  @db.Text
  llmConfidence  String?  // low, medium, high
  isPartialCredit Boolean @default(false)

  // Anti-cheat fields
  timeSpent        Int      @default(0) // milliseconds
  viewedSolutions  String[] @default([])
  similarityScore  Float?
  flagCount        Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  problem    Problem              @relation(fields: [problemId], references: [id], onDelete: Cascade)
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  flags      SubmissionFlag[]
  evaluation SubmissionEvaluation?

  @@map("submissions")
}

// Solution - Public write-ups/tutorials (题解)
model Solution {
  id        String   @id @default(cuid())
  problemId String
  userId    String
  title     String   @db.VarChar(255)
  content   String   @db.Text // Markdown content explaining the approach
  voteScore Int      @default(0)
  viewCount Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  problem Problem        @relation(fields: [problemId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  votes   SolutionVote[]

  @@map("solutions")
}

model SolutionVote {
  userId     String
  solutionId String
  vote       Int // -1, 0, 1

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  solution Solution @relation(fields: [solutionId], references: [id], onDelete: Cascade)

  @@id([userId, solutionId])
  @@map("solution_votes")
}

model Discussion {
  id          String   @id @default(cuid())
  problemId   String
  userId      String
  title       String   @db.VarChar(255)
  content     String   @db.Text
  replyCount  Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("discussions")
}

model UserProgress {
  userId         String
  problemId      String
  status         String    @default("unsolved") // unsolved, solved, bookmarked
  viewedSolution Boolean   @default(false)
  ratingGained   Boolean   @default(false) // Prevent duplicate rating gains
  startedAt      DateTime? // When user first opened problem
  lastAttempt    DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@id([userId, problemId])
  @@map("user_progress")
}

model RatingHistory {
  id            String   @id @default(cuid())
  userId        String
  problemId     String
  oldRating     Int
  newRating     Int
  change        Int // Can be negative
  problemRating Int // Problem rating at time of solve
  viewedSolution Boolean @default(false)
  verified      Boolean  @default(false)
  createdAt     DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([problemId])
  @@map("rating_history")
}

model SubmissionEvaluation {
  id           String   @id @default(cuid())
  submissionId String   @unique

  // Detailed scores
  totalScore   Int // 0-100
  correctness  Int // 0-40
  reasoning    Int // 0-30
  coverage     Int // 0-20
  clarity      Int // 0-10

  confidence   String   // low, medium, high
  feedback     String   @db.Text
  errors       String[] @default([])
  strengths    String[] @default([])
  suggestions  String[] @default([])

  // Metadata
  modelUsed      String // "gpt-4o-mini", "claude-3-haiku", etc
  promptVersion  String // Track which prompt version was used
  evaluationTime Int    // milliseconds taken
  cost           Float  // Cost in USD

  createdAt DateTime @default(now())

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  @@map("submission_evaluations")
}

model SubmissionFlag {
  id            String   @id @default(cuid())
  submissionId  String
  reporterId    String
  flaggedUserId String // User who submitted the flagged submission
  reason        String   @db.VarChar(50) // "plagiarism", "incorrect", "spam"
  details       String?  @db.Text
  status        String   @default("pending") // pending, reviewed, confirmed, rejected
  reviewedBy    String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  submission  Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  reporter    User       @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  flaggedUser User       @relation("FlaggedUser", fields: [flaggedUserId], references: [id], onDelete: Cascade)

  @@index([submissionId])
  @@index([flaggedUserId])
  @@map("submission_flags")
}

model RateLimitLog {
  id           String   @id @default(cuid())
  userId       String
  actionType   String // "submission", "llm_eval", "appeal"
  timestamp    DateTime @default(now())
  rateLimitHit Boolean  @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@map("rate_limit_logs")
}